---
title: "Movies Popularity"
author: "Ekin Kizildas, Aurora Sterpellone"
date: "2025-02-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# SCRAPING AND WORKING ON THE DATASET
## Necessary Libraries

```{r}
library(scrapex)
library(dotenv)
library(httr)
library(jsonlite)
library(furrr)
library(tidyverse)
library(future)
library(tibble)
library(dplyr)
library(fuzzyjoin)
library(rvest)
library(stringr)
library(rvest)
library(dplyr)
library(stringr)
library(tidyr)
library(tidyverse)

```

## API SETUP

```{r}
#usethis::edit_r_environ()

api_key <- Sys.getenv("api_key")

```

## SCRAPING
scrapes also for the release date

```{r}


set.seed(123)  # Ensures reproducibility
plan(multisession, workers = 4)  # Enable parallel processing


# Define time range
start_year <- 2000
end_year <- as.numeric(format(Sys.Date(), "%Y"))

# Define countries
countries <- c("US", "GB", "DE", "FR", "TR", "IN", "JP", "ES", "IT", "BR")

# Define selected languages
languages <- c("es", "fr", "de", "tr", "ja", "ru", "zh", "ko", "pt", "hi", "it")

### **STEP 1: Fetch Top 50 Movies Per Language**
fetch_movies_by_language <- function(lang) {
  movies_list <- list()

  for (page in 1:2) {  # Limit to first 2 pages (~50 movies per language)
    movie_url <- paste0("https://api.themoviedb.org/3/discover/movie?api_key=", api_key,
                        "&sort_by=popularity.desc",
                        "&primary_release_date.gte=", start_year, "-01-01",
                        "&primary_release_date.lte=", end_year, "-12-31",
                        "&vote_count.gte=500",
                        "&with_original_language=", lang,
                        "&page=", page)

    response <- tryCatch({
      GET(movie_url, timeout(10))
    }, error = function(e) NULL)

    Sys.sleep(runif(1, 1, 2))  # Short delay (1-2 sec) to avoid rate limits

    if (!is.null(response) && status_code(response) == 200) {
      movies <- fromJSON(content(response, "text", encoding = "UTF-8"))$results

      if (!is.null(movies) && length(movies) > 0) {
        movie_df <- tibble(
          movie_id = movies$id,
          title = movies$title,
          release_year = substr(movies$release_date, 1, 4),
          popularity = movies$popularity,
          original_language = movies$original_language,
          poster_path = paste0("https://image.tmdb.org/t/p/w500", movies$poster_path)
        )
        movies_list <- append(movies_list, list(movie_df))
      }
    }
  }

  if (length(movies_list) > 0) {
    return(bind_rows(movies_list))
  } else {
    return(NULL)
  }
}

# Fetch movies in parallel
all_movies <- future_map_dfr(languages, fetch_movies_by_language, .progress = TRUE, .options = furrr_options(seed = TRUE))

# Ensure data is not empty
if (nrow(all_movies) == 0) {
  stop("ðŸš¨ No movies were fetched! Check API key or language codes.")
}

### **STEP 2: Fetch Regional Release Dates**
fetch_regional_release_dates <- function(movie) {
  movie_id <- movie$movie_id
  title <- movie$title
  lang <- movie$original_language

  regional_release_dates <- future_map_dfr(countries, function(country) {
    release_dates_url <- paste0("https://api.themoviedb.org/3/movie/", movie_id,
                                "/release_dates?api_key=", api_key)

    response <- tryCatch({
      GET(release_dates_url, timeout(8))
    }, error = function(e) NULL)

    Sys.sleep(runif(1, 1, 2))  # Short delay to avoid rate limiting

    if (!is.null(response) && status_code(response) == 200) {
      release_dates_data <- fromJSON(content(response, "text", encoding = "UTF-8"))$results
      country_release_date <- release_dates_data[release_dates_data$iso_3166_1 == country, ]

      if (!is.null(country_release_date) && nrow(country_release_date) > 0) {
        return(tibble(
          movie_id = movie_id,
          title = title,
          language = lang,
          country = country,
          release_date = country_release_date$release_dates[[1]]$release_date
        ))
      }
    }
    return(NULL)
  }, .progress = TRUE, .options = furrr_options(seed = TRUE))

  return(regional_release_dates)
}

# Fetch regional release dates in parallel
all_movies_regional_release_dates <- future_map_dfr(
  split(all_movies, seq(nrow(all_movies))), 
  fetch_regional_release_dates, 
  .progress = TRUE, 
  .options = furrr_options(seed = TRUE)
)

# Ensure regional release data is not empty
if (nrow(all_movies_regional_release_dates) == 0) {
  stop("ðŸš¨ No regional release dates fetched! Check API key or country codes.")
}

# Save final dataset
write.csv(all_movies_regional_release_dates, "movies_with_regional_release_dates.csv", row.names = FALSE)

print(dim(all_movies_regional_release_dates))
head(all_movies_regional_release_dates)

```

```{r}

set.seed(123)
# Enable parallel processing (4 workers)
plan(multisession, workers = 4)

# âœ… Define time range
start_year <- 2000
end_year <- as.numeric(format(Sys.Date(), "%Y"))

# âœ… Define selected languages
languages <- c("es", "fr", "de", "tr", "ja", "ru", "zh", "ko", "pt", "hi", "it")

### **STEP 1: Fetch Top 50 Movies Per Language (Faster)**
fetch_movies_by_language <- function(lang) {
  movies_list <- list()

  for (page in 1:2) {  # âœ… Limit to first 2 pages (~50 movies per language)
    movie_url <- paste0("https://api.themoviedb.org/3/discover/movie?api_key=", api_key,
                        "&sort_by=popularity.desc",
                        "&primary_release_date.gte=", start_year, "-01-01",
                        "&primary_release_date.lte=", end_year, "-12-31",
                        "&vote_count.gte=500",
                        "&with_original_language=", lang,
                        "&page=", page)

    response <- tryCatch({
      GET(movie_url, timeout(10))
    }, error = function(e) NULL)

    Sys.sleep(runif(1, 1, 2))  # âœ… Shorter delay (1-2 sec)

    if (!is.null(response) && status_code(response) == 200) {
      movies <- fromJSON(content(response, "text", encoding = "UTF-8"))$results

      if (!is.null(movies) && length(movies) > 0) {
        movie_df <- tibble(
          movie_id = movies$id,
          title = movies$title,
          release_year = substr(movies$release_date, 1, 4),
          popularity = movies$popularity,
          original_language = movies$original_language,
          poster_path = paste0("https://image.tmdb.org/t/p/w500", movies$poster_path)
        )
        movies_list <- append(movies_list, list(movie_df))
      }
    }
  }

  if (length(movies_list) > 0) {
    return(bind_rows(movies_list))
  } else {
    return(NULL)
  }
}

# âœ… Fetch movies in parallel
all_movies <- future_map_dfr(languages, fetch_movies_by_language, .progress = TRUE, .options = furrr_options(seed = TRUE))

# âœ… Save movies dataset
write.csv(all_movies, "optimized_movies.csv", row.names = FALSE)

print(dim(all_movies))
head(all_movies)
```

## Join the 2 datasets from TMDB (UPDATED!!!)

```{r}
# Load necessary libraries
library(dplyr)

# Merge the datasets on the 'movie_id' column
merged_data <- all_movies %>%
  left_join(all_movies_regional_release_dates, by = "movie_id")


```


## Scraping for the Academy Awards

```{r}



# Wikipedia page URL
oscar_url <- "https://en.wikipedia.org/wiki/List_of_Academy_Award%E2%80%93winning_films"

# Read the page
oscar_page <- read_html(oscar_url)

# Select the table that contains the Oscar-winning movies
oscar_movies <- oscar_page %>%
  html_nodes("table.wikitable") %>%
  .[[1]] %>%
  html_table(fill = TRUE)

# Show first few rows
print(head(oscar_movies))

# Rename columns for clarity
colnames(oscar_movies) <- c("film", "year", "awards_won", "nominations")

# Clean data and handle non-numeric values safely
oscar_movies_clean <- oscar_movies %>%
  mutate(
    year = as.numeric(str_extract(year, "\\d{4}")),  # Extract only the year
    awards_won = as.numeric(gsub("[^0-9]", "", awards_won)),  # Remove non-numeric characters
    nominations = as.numeric(gsub("[^0-9]", "", nominations))  # Remove non-numeric characters
  ) %>%
  drop_na()  # Remove rows with missing values

# Show cleaned dataset
print(head(oscar_movies_clean, 10))

# Save the cleaned data to a CSV file
write.csv(oscar_movies_clean, "oscar_winning_films.csv", row.names = FALSE)

```

## Scraping for Venice's Golden Lions

```{r} 

url <- "https://en.wikipedia.org/wiki/Golden_Lion"

page <- read_html(url)

tables <- page %>%
  html_nodes("table.wikitable")

golden_lion_table <- tables[[1]] %>%
  html_table(fill = TRUE)

print(colnames(golden_lion_table))

if (any(is.na(colnames(golden_lion_table))) | any(colnames(golden_lion_table) == "")) {
  colnames(golden_lion_table) <- c("Year", "Film", "Director", "Country")
}

golden_lion_clean <- golden_lion_table %>%
  rename(year = Year, film = `English Title`, director = Director, country = `Production Country`) %>%
  filter(!is.na(year) & year != "") %>%  # BoÅŸ satÄ±rlarÄ± temizle
  mutate(
    year = as.numeric(str_extract(year, "\\d{4}")),  
    film = str_trim(film),  
    director = str_trim(director),  
    country = str_trim(country)  
  )

print(head(golden_lion_clean, 10))

write.csv(golden_lion_clean, "venice_film_festival_winners.csv", row.names = FALSE)

```

## Scraping for Cannes' Palme D'Or

```{r} 

# Wikipedia page URL for Palme d'Or winners
url <- "https://en.wikipedia.org/wiki/Palme_d%27Or"

# Read the page
page <- read_html(url)

# Get all tables from the page
tables <- page %>%
  html_nodes("table.wikitable")

# Extract tables 7, 8, and 9
table_7 <- tables[[7]] %>% html_table(fill = TRUE)
table_8 <- tables[[8]] %>% html_table(fill = TRUE)
table_9 <- tables[[9]] %>% html_table(fill = TRUE)

# Combine the tables into a single data frame
palme_dor_tables <- bind_rows(table_7, table_8, table_9)

# Check column names
print(colnames(palme_dor_tables))

# If column names are empty, assign new names
if (any(is.na(colnames(palme_dor_tables))) | any(colnames(palme_dor_tables) == "")) {
  colnames(palme_dor_tables) <- c("Year", "Film", "Director", "Country")
}

# Clean the data
palme_dor_clean <- palme_dor_tables %>%
  rename(year = Year, film = `English Title`, director = Director, country = `Production Country`) %>%
  filter(!is.na(year) & year != "") %>%  # Remove empty rows
  mutate(
    year = as.numeric(str_extract(year, "\\d{4}")),  # Extract year in numeric format
    film = str_trim(film),  # Trim film title
    director = str_trim(director),  # Trim director name
    country = str_trim(country)  # Trim country name
  )

# Display the cleaned data
print(head(palme_dor_clean, 10))

# Save the cleaned data to a CSV file
write.csv(palme_dor_clean, "cannes_film_festival_winners.csv", row.names = FALSE)

```

## Merging the Awards Datasets

1. rename columns

```{r}

# Load the datasets
cannes_winners <- palme_dor_clean
venice_winners <- golden_lion_clean
oscar_winners <- oscar_movies_clean

# Rename columns in cannes_winners
cannes_winners <- cannes_winners %>%
  rename(
    title = film,
    original_title = `Original Title`
  ) %>%
  select(year, title, original_title, director, country)

# Rename columns in venice_winners and drop the 'country' column
venice_winners <- venice_winners %>%
  rename(
    title = film,
    original_title = `Original Title`
  ) %>%
  select(-country)  # Drop the 'country' column

# Rename columns in oscar_winners
oscar_winners <- oscar_winners %>%
  rename(title = film)

```

2. binary indicators

```{r}
# Create binary indicator columns for each award

cannes_winners <- cannes_winners %>%
  mutate(palme_dor = 1) %>%
  select(title, original_title, year, director, country, palme_dor)

venice_winners <- venice_winners %>%
  mutate(golden_lion = 1) %>%
  select(title, original_title, year, director, golden_lion)

oscar_winners <- oscar_winners %>%
  mutate(academy_award = 1, academy_nominated = ifelse(nominations > 0, 1, 0)) %>%
  select(title, year, academy_award, academy_nominated)

# Merge the datasets
# First, merge Oscar winners with Cannes winners
merged_data_awards <- full_join(oscar_winners, cannes_winners, by = c("title", "year")) %>%
  mutate(
    academy_award = ifelse(is.na(academy_award), 0, academy_award),
    academy_nominated = ifelse(is.na(academy_nominated), 0, academy_nominated),
    palme_dor = ifelse(is.na(palme_dor), 0, palme_dor)
  )

# Next, merge the result with Venice winners
merged_data_awards <- full_join(merged_data_awards, venice_winners, by = c("title", "year")) %>%
  mutate(
    golden_lion = ifelse(is.na(golden_lion), 0, golden_lion)
  )

# Print the resulting dataset
print(merged_data_awards)

# Filter the dataset to include only movies from 2000 to 2025
merged_data_awards <- merged_data_awards %>%
  filter(year >= 2000 & year <= 2025)

```

3. delete original_title & director columns

```{r}
merged_data_awards <- merged_data_awards %>%
  select(-original_title.x, -original_title.y, -director.x, -director.y)

```

4. dealing with NAs in academy_award - academy_nominated - palme_dor

```{r}
merged_data_awards <- merged_data_awards %>%
  mutate(across(c(academy_award, academy_nominated, palme_dor), ~ replace(., is.na(.), 0)))

```

5. Save everything

```{r}
# Save the resulting dataset to a CSV file
write.csv(merged_data_awards, "merged_awards_data.csv", row.names = FALSE)

```

## Merging the whole dataset

```{r}


final_data <- left_join(movies_data, awards_data, by = "title")

final_data <- final_data %>%
  mutate(across(c(academy_award, academy_nominated, palme_dor, golden_lion), ~ replace(., is.na(.), 0)))

```

delete year & country.y columns & renames country

```{r}
final_data <- final_data %>%
  select(-year, -country.y, -original_language) %>%
  rename(country = country.x)

```

## Export

```{r}


write.csv(final_data, "final_data.csv")

```

# ANALYSIS & VISUALIZATIONS

## Necessary Libraries

```{r}
library(tidyverse)
library(tidytext)  
library(ggwordcloud)  
library(dplyr)  
library(ggplot2)
library(stopwords)
library(igraph)
library(ggraph)
library(scales)
library(networkD3)
library(imager)
library(stats)
library(highcharter)

```


## Ekin

```{r}
final_data <- read.csv("final_data.csv")



<<<<<<< Updated upstream
=======


>>>>>>> Stashed changes
# 1. Number of Movies by Year
ggplot(final_data, aes(x = as.factor(release_year))) +
  geom_bar(fill = "blue", alpha = 0.7) +
  labs(title = "Number of Movies by Year", x = "Release Year", y = "Movie Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# 2. Movie Distribution by Country (Top 10 countries producing the most movies)
top_countries <-final_data %>%
  count(country, sort = TRUE) %>%
  top_n(10, n)

ggplot(top_countries, aes(x = reorder(country, n), y = n)) +
  geom_bar(stat = "identity", fill = "red", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 10 Countries Producing the Most Movies", x = "Country", y = "Movie Count") +
  theme_minimal()

# 3. Popularity Distribution
ggplot(final_data, aes(x = popularity)) +
  geom_histogram(bins = 20, fill = "green", color = "black", alpha = 0.7) +
  labs(title = "Popularity Distribution", x = "Popularity", y = "Movie Count") +
  theme_minimal()

# 4. Award Distribution
award_data <- final_data%>%
  summarise(
    academy_award = sum(academy_award),
    academy_nominated = sum(academy_nominated),
    palme_dor = sum(palme_dor),
    golden_lion = sum(golden_lion)
  ) %>%
  pivot_longer(cols = everything(), names_to = "award", values_to = "count")

ggplot(award_data, aes(x = award, y = count, fill = award)) +
  geom_bar(stat = "identity", alpha = 0.7) +
  labs(title = "Distribution of Awards", x = "Award Type", y = "Total Count") +
  theme_minimal()

# 5. Language Distribution (Top 10 most used languages)
top_languages <- final_data%>%
  count(language, sort = TRUE) %>%
  top_n(10, n)

ggplot(top_languages, aes(x = reorder(language, n), y = n)) +
  geom_bar(stat = "identity", fill = "purple", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 10 Most Used Languages", x = "Language", y = "Movie Count") +
  theme_minimal()

```

```{r}
<<<<<<< Updated upstream
df <- df %>%
  dplyr::select(-year, -country.y, -original_language) %>%
  rename(country = country.x)
=======



>>>>>>> Stashed changes

# Get top 10 countries producing the most movies
top_countries <- final_data %>%
  count(country, sort = TRUE) %>%
  top_n(10, n)

# Bar plot
ggplot(top_countries, aes(x = reorder(country, n), y = n, fill = country)) +
  geom_bar(stat = "identity") +
  coord_flip() +  # Flip axes for readability
  labs(title = "Top 10 Movie-Producing Countries", x = "Country", y = "Number of Movies") +
  theme_minimal()


```



```{r}
# Calculate total awards
final_data <- final_data %>%
  mutate(total_awards = academy_award + academy_nominated + palme_dor + golden_lion)

# Scatter plot
ggplot(df, aes(x = popularity, y = total_awards)) +
  geom_point(alpha = 0.6, color = "purple") +
  geom_smooth(method = "lm", color = "red", se = FALSE) +  # Regression line
  labs(title = "Popularity vs. Awards", x = "Popularity", y = "Total Awards") +
  theme_minimal()

```

```{r}
<<<<<<< Updated upstream
word_data <- df %>%
=======

library(tidytext)  
library(ggwordcloud)  
library(dplyr)  
library(ggplot2)
library(stopwords)

word_data <- final_data %>%
>>>>>>> Stashed changes
  filter(!is.na(title)) %>%
  unnest_tokens(word, title) %>%
  count(word, sort = TRUE) %>%
  filter(n > 5)  # Keep words appearing more than 5 times

# Remove stop words (English and other common words)
word_data <- word_data %>%
  filter(!word %in% stopwords("en"))  # Remove common English stop words

# Improved Word Cloud
ggplot(word_data, aes(label = word, size = n, color = n)) +
  geom_text_wordcloud() +
  scale_color_viridis_c() +
  labs(title = "Most Common Words in Movie Titles ") +
  theme_minimal()

```

```{r}
<<<<<<< Updated upstream
df_countries <- df %>%
  select(title, country) %>%
  filter(!is.na(country)) %>%
  separate_rows(country, sep = ",")  # Adjust separator if needed

# Generate country pairs for each movie
edges <- df_countries %>%
=======
library(dplyr)
library(tidyr)
library(igraph)
library(ggraph)

df_pairs <- final_data %>%
>>>>>>> Stashed changes
  group_by(title) %>%
  summarise(
    country_pairs = if (n_distinct(country) > 1) {
      list(combn(unique(country), 2, simplify = FALSE))  # Generate country pairs
    } else {
      list(NULL)  # Skip movies with only one country
    }
  ) %>%
  unnest(country_pairs) %>%  
  filter(!is.null(country_pairs)) %>%  
  unnest_wider(country_pairs, names_sep = "_") %>%  
  rename(from = country_pairs_1, to = country_pairs_2) %>%
  count(from, to, name = "weight")  # Count co-productions



# Create graph object
country_graph <- graph_from_data_frame(df_pairs, directed = FALSE)

# Calculate node size based on total collaborations
node_sizes <- data.frame(name = V(country_graph)$name) %>%
  left_join(edges %>% 
              group_by(from) %>% 
              summarise(size = sum(weight)), 
            by = c("name" = "from")) %>%
  replace_na(list(size = 1))  # Replace missing values with 1

# Enhanced network graph visualization
ggraph(country_graph, layout = "fr") +  
  geom_edge_link(aes(edge_width = weight, alpha = weight), color = "gray") +  
    scale_edge_width(range = c(0.5, 5), trans = "log10") +  # Proper log-scaling
  geom_node_point(aes(size = node_sizes$size), color = "darkblue") +  
  geom_node_text(aes(label = name), repel = TRUE, size = 5, fontface = "bold") +  
  theme_void() +  
  labs(title = "Enhanced Movie Co-Production Network",
       subtitle = "Edge thickness represents number of collaborations",
       edge_width = "Co-Productions")

```

Looking at the visualization, we can see that some countries, like the United States (US), France (FR), and Germany (DE), have larger nodes. This indicates that they are key players in international co-productions, frequently working with multiple other nations. The thickness of the edges reveals which partnerships are the strongest. For example, if there is a thick line between US and FR, it means these two countries have collaborated on many films.

In contrast, some countries, like Brazil (BR) or Italy (IT), have smaller nodes, meaning they are involved in fewer co-productions. They might still play a role in international films but not as frequently as the major hubs. Additionally, some countries may have only a few connections, suggesting that they primarily produce films domestically rather than engaging in frequent international partnerships.

```{r}
library(httr)
library(magick)
library(dplyr)




df_posters <- final_data %>%
  filter(!is.na(poster_path)) %>% 
  distinct(poster_path, .keep_all = TRUE) %>%  
  select(title, poster_path, popularity) %>%
  head(179) 



for (i in 1:nrow(df_posters)) {
  url <- df_posters$poster_path[i]
  file_name <- paste0(poster_folder, gsub("[^A-Za-z0-9]", "_", df_posters$title[i]), ".jpg")
  
  if (!is.na(url) && grepl("^https?://", url)) {  
    print(paste("Downloading:", url))
    
    if (!file.exists(file_name)) {  
      try(GET(url, write_disk(file_name, overwrite = TRUE)), silent = TRUE)
    }
  } else {
    print(paste("Invalid URL:", url))
  }
}

print("Downloaded")

```



```{r}

poster_folder <- "posters/"
poster_files <- list.files(poster_folder, full.names = TRUE)

# Birden fazla posterde analiz yapalÄ±m
all_dominant_colors <- data.frame(movie = character(),
                                  r = numeric(), g = numeric(), b = numeric(), hex = character())

for (file in poster_files) {
  # Renkleri Ã§Ä±kart
  dominant_colors <- extract_colors(file, n_colors = 2)
  
  # Film adÄ±nÄ± dosya isminden al
  movie_name <- gsub(".jpg", "", basename(file))
  
  # RGB deÄŸerlerini HEX formatÄ±na Ã§evir
  dominant_colors$hex <- rgb(dominant_colors$r / 255, 
                             dominant_colors$g / 255, 
                             dominant_colors$b / 255)
  
  # Sonucu birleÅŸtir
  dominant_colors$movie <- movie_name
  all_dominant_colors <- bind_rows(all_dominant_colors, dominant_colors)
}

# SonuÃ§larÄ± gÃ¶relim
print(all_dominant_colors)
```




```{r}
language_colors_grouped <- language_colors_grouped %>%
  group_by(language) %>%
  summarise(r = mean(r), g = mean(g), b = mean(b), hex = first(hex), .groups = "drop")

ggplot(language_colors_grouped, aes(x = reorder(language, -r), y = 1, fill = hex)) +
  geom_bar(stat = "identity", width = 0.5) + 
  scale_fill_identity() +
  theme_minimal() +
  coord_flip() +
  labs(title = "Dominant Colors by Language",
       x = "Language",
       y = "Dominant Color")

```

```{r}


poster_folder <- "posters/"
poster_files <- list.files(poster_folder, full.names = TRUE)

# TÃ¼m filmler iÃ§in baskÄ±n rengi ve yÄ±lÄ± bulalÄ±m
year_colors <- data.frame(year = integer(),
                          r = numeric(), g = numeric(), b = numeric(), hex = character())

for (file in poster_files) {
  dominant_colors <- extract_colors(file, n_colors = 1)  # En baskÄ±n rengi al
  movie_name <- gsub(".jpg", "", basename(file))
  
  # Film yÄ±lÄ±nÄ± datasetten alalÄ±m
  movie_year <- df %>% filter(grepl(movie_name, title, ignore.case = TRUE)) %>% pull(release_year)
  
  # EÄŸer yÄ±l bilgisi varsa
  if (length(movie_year) > 0) {
    dominant_colors$hex <- rgb(dominant_colors$r / 255, 
                               dominant_colors$g / 255, 
                               dominant_colors$b / 255)
    
    dominant_colors$year <- movie_year[1]  # YÄ±lÄ±n ilk deÄŸerini al
    year_colors <- bind_rows(year_colors, dominant_colors)
  }
}

# YÄ±llara gÃ¶re baskÄ±n renklerin ortalamasÄ±nÄ± alalÄ±m (REPLACED summarise() -> reframe())
year_colors_grouped <- year_colors %>%
  group_by(year) %>%
  reframe(r = mean(r), g = mean(g), b = mean(b), hex = unique(hex))

ggplot(year_colors_grouped, aes(x = year, y = r, color = hex)) +
  geom_point(size = 4, alpha = 0.8) +  # Daha bÃ¼yÃ¼k ve saydam noktalar
  geom_smooth(method = "loess", color = "blue", se = FALSE) +  # Trend Ã§izgisi ekle
  scale_color_identity() +  # DoÄŸrudan hex kodlarÄ±nÄ± renk olarak ata
  theme_minimal() +
  labs(title = "Film Poster Colors Over the Years",
       subtitle = "A shift in dominant poster colors over time",
       x = "Year",
       y = "Red Intensity (Proxy for Overall Color Trend)")


```


```{r}
ggplot(year_colors_grouped, aes(x = year, y = 1, fill = hex)) +
  geom_tile() +
  scale_fill_identity() +
  theme_minimal() +
  labs(title = "Dominant Film Poster Colors by Year",
       x = "Year",
       y = "Color Representation")

```

```{r}


extract_colors <- function(image_path, n_colors = 3) {  
  img <- load.image(image_path)  # GÃ¶rseli yÃ¼kle
  
  # GÃ¶rseli kÃ¼Ã§Ã¼ltÃ¼p iÅŸlem hÄ±zÄ±nÄ± artÄ±r
  img_resized <- resize(img, size_x = 300, size_y = 300)  

  # RGB piksel verisini al
  img_data <- as.data.frame(as.array(img_resized))
  img_data <- img_data[, 1:3]  # Sadece RGB kanallarÄ±nÄ± al
  names(img_data) <- c("r", "g", "b")  

  # RGB deÄŸerlerini 0-255 aralÄ±ÄŸÄ±na getir
  img_data$r <- img_data$r * 255
  img_data$g <- img_data$g * 255
  img_data$b <- img_data$b * 255

  # Benzersiz renklerin sayÄ±sÄ±nÄ± belirle
  unique_colors <- nrow(unique(img_data))

  # EÄŸer benzersiz renk sayÄ±sÄ± seÃ§ilen `n_colors` deÄŸerinden kÃ¼Ã§Ã¼kse, `n_colors`'Ä± ayarla
  kmeans_clusters <- min(n_colors, unique_colors)

  # K-Means ile baskÄ±n renkleri belirle (minimized n_colors)
  kmeans_result <- kmeans(img_data, centers = kmeans_clusters, iter.max = 100)
  dominant_colors <- as.data.frame(kmeans_result$centers)
  
  return(dominant_colors)
}


```


```{r}


extract_colors <- function(image_path, n_colors = 3) {  
  img <- load.image(image_path)  # GÃ¶rseli yÃ¼kle
  
  # GÃ¶rseli kÃ¼Ã§Ã¼ltÃ¼p iÅŸlem hÄ±zÄ±nÄ± artÄ±r
  img_resized <- resize(img, size_x = 300, size_y = 300)  

  # RGB piksel verisini al
  img_data <- as.data.frame(as.array(img_resized))
  img_data <- img_data[, 1:3]  # Sadece RGB kanallarÄ±nÄ± al
  names(img_data) <- c("r", "g", "b")  

  # RGB deÄŸerlerini 0-255 aralÄ±ÄŸÄ±na getir
  img_data$r <- img_data$r * 255
  img_data$g <- img_data$g * 255
  img_data$b <- img_data$b * 255

  # Tekrar eden renkleri kaldÄ±r ve benzersiz renkleri bul
  unique_colors <- unique(img_data)

  # EÄŸer benzersiz renk sayÄ±sÄ± `n_colors`'tan azsa, onu otomatik ayarla
  kmeans_clusters <- min(n_colors, nrow(unique_colors))

  # EÄŸer yalnÄ±zca 1 renk varsa, doÄŸrudan dÃ¶ndÃ¼r
  if (kmeans_clusters == 1) {
    return(data.frame(r = unique_colors$r, g = unique_colors$g, b = unique_colors$b))
  }

  # K-Means ile baskÄ±n renkleri belirle (sadece uygun sayÄ±da kÃ¼me kullan)
  kmeans_result <- kmeans(unique_colors, centers = kmeans_clusters, iter.max = 100)
  dominant_colors <- as.data.frame(kmeans_result$centers)
  
  return(dominant_colors)
}




```



```{r}

color_grid_data <- popularity_colors %>%
  select(hex) %>%
  mutate(film = row_number())  

color_grid_data <- color_grid_data %>%
  filter(!hex %in% c("#000000", "#1A1A1A", "#2A2A2A")) 

ggplot(color_grid_data, aes(x = film %% 10, y = film %/% 10, fill = hex)) + 
  geom_tile(color = "white", size = 0.5) +  
  scale_fill_identity() + 
  theme_void() +
  labs(title = "Movie Poster Color Grid")

```



```{r}



color_counts <- popularity_colors %>%
  count(hex, sort = TRUE)  

rare_colors <- color_counts %>% tail(10)

ggplot(rare_colors, aes(x = reorder(hex, n), y = n, fill = hex)) +
  geom_bar(stat = "identity", width = 0.7) +
  scale_fill_identity() +
  theme_minimal() +
  coord_flip() +
  labs(title = "Least Used Colors in Movie Posters",
       x = "Color",
       y = "Number of Movies")



```


## Au

## Preparing the data

```{r}
# Assuming final_data is your dataset
# Group by movie title and summarize the data
grouped_data <- final_data %>%
  group_by(title) %>%
  summarise(
    movie_id = first(movie_id),
    release_year = first(release_year),
    popularity = mean(popularity, na.rm = TRUE),
    poster_path = first(poster_path),
    language = first(language),
    country = toString(unique(country)),  # Combine unique countries
    release_date = toString(unique(release_date)),  # Combine unique release dates
    academy_award = max(academy_award),
    academy_nominated = max(academy_nominated),
    palme_dor = max(palme_dor),
    golden_lion = max(golden_lion)
  ) %>%
  ungroup()

# Filter the top 10 most popular movies
top_10_movies <- grouped_data %>%
  arrange(desc(popularity)) %>%
  head(10)

```


::: {.panel-tabset .nav-pills}
## Awards Distribution
to show the distribution of different awards won by the top 10 movies
### all movies

```{r}
# Create a bar plot to show the distribution of different awards won by movies
awards_distribution <- final_data %>%
  select(academy_award, academy_nominated, palme_dor, golden_lion) %>%
  summarise_all(sum) %>%
  pivot_longer(cols = everything(), names_to = "Award", values_to = "Count")

highchart() %>%
  hc_chart(type = 'column') %>%
  hc_xAxis(categories = awards_distribution$Award) %>%
  hc_add_series(name = "Awards Count", data = awards_distribution$Count, color = "#1c9099") %>%
  hc_title(text = "Awards Distribution") %>%
  hc_subtitle(text = "All movies")
```

### top 10 movies

```{r}
# Create a bar plot to show the distribution of different awards won by movies
awards_distribution <- top_10_movies %>%
  select(academy_award, academy_nominated, palme_dor, golden_lion) %>%
  summarise_all(sum) %>%
  pivot_longer(cols = everything(), names_to = "Award", values_to = "Count")

highchart() %>%
  hc_chart(type = 'column') %>%
  hc_xAxis(categories = awards_distribution$Award) %>%
  hc_add_series(name = "Awards Count", data = awards_distribution$Count, color = "#8856a7") %>%
  hc_title(text = "Awards Distribution") %>%
  hc_subtitle(text = "Top 10 Most Popular Movies")

```
:::

## Top Movies by Popularity

a bar plot to highlight the top 10 movies by popularity and show their awards

```{r}
# Create a bar plot to highlight the top 10 movies by popularity and show their awards
highchart() %>%
  hc_chart(type = 'column') %>%
  hc_xAxis(categories = top_10_movies$title) %>%
  hc_add_series(name = "Popularity", data = top_10_movies$popularity, color = "#dd1c77") %>%
  hc_add_series(name = "Academy Award", data = top_10_movies$academy_award, type = 'line', color = "darkgreen") %>%
  hc_add_series(name = "Academy Nominated", data = top_10_movies$academy_nominated, type = 'line', color = "#31a354") %>%
  hc_add_series(name = "Palme D'Or", data = top_10_movies$palme_dor, type = 'line', color = "#a1d99b") %>%
  hc_add_series(name = "Golden Lion", data = top_10_movies$golden_lion, type = 'line', color = "#e5f5e0") %>%
  hc_title(text = "Top Movies by Popularity and Awards") %>%
  hc_subtitle(text = "Highlighting Awards Won")

```


## Popularity by release year

[Line chart]
This chart will show how the average popularity of movies has changed over the years. It can help identify trends in movie popularity over time.

```{r}
# Calculate average popularity by release year
popularity_by_year <- grouped_data %>%
  group_by(release_year) %>%
  summarise(avg_popularity = mean(popularity, na.rm = TRUE))

# Create a line chart
highchart() %>%
  hc_chart(type = 'line') %>%
  hc_xAxis(title = list(text = "Release Year"), categories = popularity_by_year$release_year) %>%
  hc_add_series(name = "Average Popularity", data = popularity_by_year$avg_popularity, color = "#8856a7") %>%
  hc_title(text = "Average Movie Popularity by Release Year") %>%
  hc_subtitle(text = "Trends in Movie Popularity Over Time")


```

## !!! Awards vs Popularity

## Heatmap of Awards and Popularity 


