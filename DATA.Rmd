---
title: "Movies Popularity"
author: "Ekin Kizildas, Aurora Sterpellone"
date: "2025-02-23"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Necessary Libraries

```{r}
library(scrapex)
library(dotenv)
library(httr)
library(jsonlite)
library(furrr)
library(tidyverse)
library(future)
library(tibble)
library(dplyr)
library(fuzzyjoin)
library(rvest)
library(stringr)

```


## API SETUP:

```{r}
#usethis::edit_r_environ()

api_key <- Sys.getenv("api_key")

```

## SCRAPING
scrapes for the movie id, title, year of release, popularity score, original language, poster

```{r}
set.seed(123)
# ✅ Enable parallel processing (4 workers)
plan(multisession, workers = 4)

# ✅ Define time range
start_year <- 2000
end_year <- as.numeric(format(Sys.Date(), "%Y"))

# ✅ Define countries
countries <- c("US", "GB", "DE", "FR", "TR", "IN", "JP", "ES", "IT", "BR")

# ✅ Define selected languages
languages <- c("es", "fr", "de", "tr", "ja", "ru", "zh", "ko", "pt", "hi", "it")

### **STEP 1: Fetch Top 50 Movies Per Language (Faster)**
fetch_movies_by_language <- function(lang) {
  movies_list <- list()

  for (page in 1:2) {  # ✅ Limit to first 2 pages (~50 movies per language)
    movie_url <- paste0("https://api.themoviedb.org/3/discover/movie?api_key=", api_key,
                        "&sort_by=popularity.desc",
                        "&primary_release_date.gte=", start_year, "-01-01",
                        "&primary_release_date.lte=", end_year, "-12-31",
                        "&vote_count.gte=500",
                        "&with_original_language=", lang,
                        "&page=", page)

    response <- tryCatch({
      GET(movie_url, timeout(10))
    }, error = function(e) NULL)

    Sys.sleep(runif(1, 1, 2))  # ✅ Shorter delay (1-2 sec)

    if (!is.null(response) && status_code(response) == 200) {
      movies <- fromJSON(content(response, "text", encoding = "UTF-8"))$results

      if (!is.null(movies) && length(movies) > 0) {
        movie_df <- tibble(
          movie_id = movies$id,
          title = movies$title,
          release_year = substr(movies$release_date, 1, 4),
          popularity = movies$popularity,
          original_language = movies$original_language,
          poster_path = paste0("https://image.tmdb.org/t/p/w500", movies$poster_path)
        )
        movies_list <- append(movies_list, list(movie_df))
      }
    }
  }

  if (length(movies_list) > 0) {
    return(bind_rows(movies_list))
  } else {
    return(NULL)
  }
}

# ✅ Fetch movies in parallel
all_movies <- future_map_dfr(languages, fetch_movies_by_language, .progress = TRUE, .options = furrr_options(seed = TRUE))

### **STEP 2: Fetch Regional Release Dates**
fetch_regional_release_dates <- function(movie) {
  movie_id <- movie$movie_id
  title <- movie$title
  lang <- movie$original_language

  regional_release_dates <- future_map_dfr(countries, function(country) {
    release_dates_url <- paste0("https://api.themoviedb.org/3/movie/", movie_id,
                                "/release_dates?api_key=", api_key)

    response <- tryCatch({
      GET(release_dates_url, timeout(8))
    }, error = function(e) NULL)

    Sys.sleep(runif(1, 1, 2))  # ✅ Less waiting time

    if (!is.null(response) && status_code(response) == 200) {
      release_dates_data <- fromJSON(content(response, "text", encoding = "UTF-8"))$results
      country_release_date <- release_dates_data[release_dates_data$iso_3166_1 == country, ]

      if (nrow(country_release_date) > 0) {
        return(tibble(
          movie_id = movie_id,
          title = title,
          language = lang,
          country = country,
          release_date = country_release_date$release_dates[[1]]$release_date
        ))
      }
    }
    return(NULL)
  }, .progress = TRUE)

  return(regional_release_dates)
}

# ✅ Fetch regional release dates in parallel for multiple movies at once
all_movies_regional_release_dates <- future_map_dfr(split(all_movies, seq(nrow(all_movies))), fetch_regional_release_dates, .progress = TRUE, .options = furrr_options(seed = TRUE))

# ✅ Save final dataset
write.csv(all_movies_regional_release_dates, "movies_with_regional_release_dates.csv", row.names = FALSE)

print(dim(all_movies_regional_release_dates))
head(all_movies_regional_release_dates)
```


scrapes also for the release date
```{r}

set.seed(123)
# Enable parallel processing (4 workers)
plan(multisession, workers = 4)

# ✅ Define time range
start_year <- 2000
end_year <- as.numeric(format(Sys.Date(), "%Y"))

# ✅ Define selected languages
languages <- c("es", "fr", "de", "tr", "ja", "ru", "zh", "ko", "pt", "hi", "it")

### **STEP 1: Fetch Top 50 Movies Per Language (Faster)**
fetch_movies_by_language <- function(lang) {
  movies_list <- list()

  for (page in 1:2) {  # ✅ Limit to first 2 pages (~50 movies per language)
    movie_url <- paste0("https://api.themoviedb.org/3/discover/movie?api_key=", api_key,
                        "&sort_by=popularity.desc",
                        "&primary_release_date.gte=", start_year, "-01-01",
                        "&primary_release_date.lte=", end_year, "-12-31",
                        "&vote_count.gte=500",
                        "&with_original_language=", lang,
                        "&page=", page)

    response <- tryCatch({
      GET(movie_url, timeout(10))
    }, error = function(e) NULL)

    Sys.sleep(runif(1, 1, 2))  # ✅ Shorter delay (1-2 sec)

    if (!is.null(response) && status_code(response) == 200) {
      movies <- fromJSON(content(response, "text", encoding = "UTF-8"))$results

      if (!is.null(movies) && length(movies) > 0) {
        movie_df <- tibble(
          movie_id = movies$id,
          title = movies$title,
          release_year = substr(movies$release_date, 1, 4),
          popularity = movies$popularity,
          original_language = movies$original_language,
          poster_path = paste0("https://image.tmdb.org/t/p/w500", movies$poster_path)
        )
        movies_list <- append(movies_list, list(movie_df))
      }
    }
  }

  if (length(movies_list) > 0) {
    return(bind_rows(movies_list))
  } else {
    return(NULL)
  }
}

# ✅ Fetch movies in parallel
all_movies <- future_map_dfr(languages, fetch_movies_by_language, .progress = TRUE, .options = furrr_options(seed = TRUE))

# ✅ Save movies dataset
write.csv(all_movies, "optimized_movies.csv", row.names = FALSE)

print(dim(all_movies))
head(all_movies)
```


## Join the 2 datasets from TMDB

```{r}

merged_df <- stringdist_inner_join(all_movies, all_movies_regional_release_dates, 
                                   by = "title", max_dist = 2, method = "jw")

# View result
print(dim(merged_df))
head(merged_df)


merged_df<- merged_df %>%
  select(movie_id = movie_id.x, title = title.x, release_year, popularity, 
         original_language, poster_path, language, country, release_date)


head(merged_df)

```


## Getting Academy Awards

```{r}

# Wikipedia page URL
oscar_url <- "https://en.wikipedia.org/wiki/List_of_Academy_Award%E2%80%93winning_films"

# Read the page
oscar_page <- read_html(oscar_url)

# Select the table that contains the Oscar-winning movies
oscar_movies <- oscar_page %>%
  html_nodes("table.wikitable") %>%
  .[[1]] %>%  # First table contains the main list
  html_table(fill = TRUE)

# Show the first few rows
print(head(oscar_movies))

# Rename columns for clarity
colnames(oscar_movies) <- c("film", "year", "awards_won", "nominations")

# Clean data
oscar_movies_clean <- oscar_movies %>%
  mutate(
    year = as.numeric(str_extract(year, "\\d{4}")),  # Extract only the year
    awards_won = as.numeric(awards_won),  # Convert to numeric
    nominations = as.numeric(nominations)  # Convert to numeric
  ) %>%
  drop_na()  # Remove rows with missing values

# Show cleaned dataset
print(head(oscar_movies_clean, 10))

# Save the cleaned data to a CSV file
write.csv(oscar_movies_clean, "oscar_winning_films.csv", row.names = FALSE)

```


## Getting Venice's Golden Lions

```{r} 

url <- "https://en.wikipedia.org/wiki/Golden_Lion"

page <- read_html(url)

tables <- page %>%
  html_nodes("table.wikitable")

golden_lion_table <- tables[[1]] %>%
  html_table(fill = TRUE)

print(colnames(golden_lion_table))

if (any(is.na(colnames(golden_lion_table))) | any(colnames(golden_lion_table) == "")) {
  colnames(golden_lion_table) <- c("Year", "Film", "Director", "Country")
}

golden_lion_clean <- golden_lion_table %>%
  rename(year = Year, film = `English Title`, director = Director, country = `Production Country`) %>%
  filter(!is.na(year) & year != "") %>%  # Boş satırları temizle
  mutate(
    year = as.numeric(str_extract(year, "\\d{4}")),  
    film = str_trim(film),  
    director = str_trim(director),  
    country = str_trim(country)  
  )

print(head(golden_lion_clean, 10))

write.csv(golden_lion_clean, "venice_film_festival_winners.csv", row.names = FALSE)

```


## Getting Cannes' Palme D'Or

```{r} 

# Wikipedia page URL for Palme d'Or winners
url <- "https://en.wikipedia.org/wiki/Palme_d%27Or"

# Read the page
page <- read_html(url)

# Get all tables from the page
tables <- page %>%
  html_nodes("table.wikitable")

# Extract tables 7, 8, and 9
table_7 <- tables[[7]] %>% html_table(fill = TRUE)
table_8 <- tables[[8]] %>% html_table(fill = TRUE)
table_9 <- tables[[9]] %>% html_table(fill = TRUE)

# Combine the tables into a single data frame
palme_dor_tables <- bind_rows(table_7, table_8, table_9)

# Check column names
print(colnames(palme_dor_tables))

# If column names are empty, assign new names
if (any(is.na(colnames(palme_dor_tables))) | any(colnames(palme_dor_tables) == "")) {
  colnames(palme_dor_tables) <- c("Year", "Film", "Director", "Country")
}

# Clean the data
palme_dor_clean <- palme_dor_tables %>%
  rename(year = Year, film = `English Title`, director = Director, country = `Production Country`) %>%
  filter(!is.na(year) & year != "") %>%  # Remove empty rows
  mutate(
    year = as.numeric(str_extract(year, "\\d{4}")),  # Extract year in numeric format
    film = str_trim(film),  # Trim film title
    director = str_trim(director),  # Trim director name
    country = str_trim(country)  # Trim country name
  )

# Display the cleaned data
print(head(palme_dor_clean, 10))

# Save the cleaned data to a CSV file
write.csv(palme_dor_clean, "cannes_film_festival_winners.csv", row.names = FALSE)

```


## Merging the Awards Datasets

1. rename columns

```{r}

# Load the datasets
cannes_winners <- read_csv("cannes_film_festival_winners.csv")
venice_winners <- read_csv("venice_film_festival_winners.csv")
oscar_winners <- read_csv("oscar_winning_films.csv")

# Rename columns in cannes_winners
cannes_winners <- cannes_winners %>%
  rename(
    title = film,
    original_title = `Original Title`
  ) %>%
  select(year, title, original_title, director, country)

# Rename columns in venice_winners and drop the 'country' column
venice_winners <- venice_winners %>%
  rename(
    title = film,
    original_title = `Original Title`
  ) %>%
  select(-country)  # Drop the 'country' column

# Rename columns in oscar_winners
oscar_winners <- oscar_winners %>%
  rename(title = film)

```

2. binary indicators

```{r}
# Create binary indicator columns for each award

cannes_winners <- cannes_winners %>%
  mutate(palme_dor = 1) %>%
  select(title, original_title, year, director, country, palme_dor)

venice_winners <- venice_winners %>%
  mutate(golden_lion = 1) %>%
  select(title, original_title, year, director, golden_lion)

oscar_winners <- oscar_winners %>%
  mutate(academy_award = 1, academy_nominated = ifelse(nominations > 0, 1, 0)) %>%
  select(title, year, academy_award, academy_nominated)

# Merge the datasets
# First, merge Oscar winners with Cannes winners
merged_data <- full_join(oscar_winners, cannes_winners, by = c("title", "year")) %>%
  mutate(
    academy_award = ifelse(is.na(academy_award), 0, academy_award),
    academy_nominated = ifelse(is.na(academy_nominated), 0, academy_nominated),
    palme_dor = ifelse(is.na(palme_dor), 0, palme_dor)
  )

# Next, merge the result with Venice winners
merged_data <- full_join(merged_data, venice_winners, by = c("title", "year")) %>%
  mutate(
    golden_lion = ifelse(is.na(golden_lion), 0, golden_lion)
  )

# Print the resulting dataset
print(merged_data)

# Filter the dataset to include only movies from 2000 to 2025
merged_data <- merged_data %>%
  filter(year >= 2000 & year <= 2025)

```


3. delete original_title & director columns

```{r}
merged_data <- merged_data %>%
  select(-original_title.x, -original_title.y, -director.x, -director.y)

```

4. dealing with NAs in academy_award - academy_nominated - palme_dor

```{r}
merged_data <- merged_data %>%
  mutate(across(c(academy_award, academy_nominated, palme_dor), ~ replace(., is.na(.), 0)))

```

5. SAVE EVERYTHING:

```{r}
# Save the resulting dataset to a CSV file
write.csv(merged_data, "merged_awards_data.csv", row.names = FALSE)

```

## MERGING THE WHOLE DATASET

```{r}

awards_data <-  merged_data
movies_data <-  merged_df

final_data <- left_join(movies_data, awards_data, by = "title")

final_data <- final_data %>%
  mutate(across(c(academy_award, academy_nominated, palme_dor, golden_lion), ~ replace(., is.na(.), 0)))

```

delete year & country.y columns & renames country

```{r}
final_data <- final_data %>%
  select(-year, -country.y, -original_language) %>%
  rename(country = country.x)

```

export

```{r}


write.csv(final_data, "final_data.csv")

```



```{r}
df <- read.csv("final_data.csv")



library(tidyverse)

# 1. Number of Movies by Year
ggplot(df, aes(x = as.factor(release_year))) +
  geom_bar(fill = "blue", alpha = 0.7) +
  labs(title = "Number of Movies by Year", x = "Release Year", y = "Movie Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# 2. Movie Distribution by Country (Top 10 countries producing the most movies)
top_countries <- df %>%
  count(country, sort = TRUE) %>%
  top_n(10, n)

ggplot(top_countries, aes(x = reorder(country, n), y = n)) +
  geom_bar(stat = "identity", fill = "red", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 10 Countries Producing the Most Movies", x = "Country", y = "Movie Count") +
  theme_minimal()

# 3. Popularity Distribution
ggplot(df, aes(x = popularity)) +
  geom_histogram(bins = 20, fill = "green", color = "black", alpha = 0.7) +
  labs(title = "Popularity Distribution", x = "Popularity", y = "Movie Count") +
  theme_minimal()

# 4. Award Distribution
award_data <- df %>%
  summarise(
    academy_award = sum(academy_award),
    academy_nominated = sum(academy_nominated),
    palme_dor = sum(palme_dor),
    golden_lion = sum(golden_lion)
  ) %>%
  pivot_longer(cols = everything(), names_to = "award", values_to = "count")

ggplot(award_data, aes(x = award, y = count, fill = award)) +
  geom_bar(stat = "identity", alpha = 0.7) +
  labs(title = "Distribution of Awards", x = "Award Type", y = "Total Count") +
  theme_minimal()

# 5. Language Distribution (Top 10 most used languages)
top_languages <- df %>%
  count(language, sort = TRUE) %>%
  top_n(10, n)

ggplot(top_languages, aes(x = reorder(language, n), y = n)) +
  geom_bar(stat = "identity", fill = "purple", alpha = 0.7) +
  coord_flip() +
  labs(title = "Top 10 Most Used Languages", x = "Language", y = "Movie Count") +
  theme_minimal()

```

```{r}
library(tidyverse)

df <- df %>%
  dplyr::select(-year, -country.y, -original_language) %>%
  rename(country = country.x)

# Get top 10 countries producing the most movies
top_countries <- df %>%
  count(country, sort = TRUE) %>%
  top_n(10, n)

# Bar plot
ggplot(top_countries, aes(x = reorder(country, n), y = n, fill = country)) +
  geom_bar(stat = "identity") +
  coord_flip() +  # Flip axes for readability
  labs(title = "Top 10 Movie-Producing Countries", x = "Country", y = "Number of Movies") +
  theme_minimal()


```



```{r}
# Calculate total awards
df <- df %>%
  mutate(total_awards = academy_award + academy_nominated + palme_dor + golden_lion)

# Scatter plot
ggplot(df, aes(x = popularity, y = total_awards)) +
  geom_point(alpha = 0.6, color = "purple") +
  geom_smooth(method = "lm", color = "red", se = FALSE) +  # Regression line
  labs(title = "Popularity vs. Awards", x = "Popularity", y = "Total Awards") +
  theme_minimal()

```

```{r}

library(tidytext)  
library(ggwordcloud)  
library(dplyr)  
library(ggplot2)
library(stopwords)

word_data <- df %>%
  filter(!is.na(title)) %>%
  unnest_tokens(word, title) %>%
  count(word, sort = TRUE) %>%
  filter(n > 5)  # Keep words appearing more than 5 times

# Remove stop words (English and other common words)
word_data <- word_data %>%
  filter(!word %in% stopwords("en"))  # Remove common English stop words

# Improved Word Cloud
ggplot(word_data, aes(label = word, size = n, color = n)) +
  geom_text_wordcloud() +
  scale_color_viridis_c() +
  labs(title = "Most Common Words in Movie Titles ") +
  theme_minimal()

```

```{r}
library(igraph)
library(ggraph)
library(tidyverse)
library(scales)



df_countries <- df %>%
  select(title, country) %>%
  filter(!is.na(country)) %>%
  separate_rows(country, sep = ",")  # Adjust separator if needed

# Generate country pairs for each movie
edges <- df_countries %>%
  group_by(title) %>%
  summarise(country_pairs = list(combn(unique(country), 2, simplify = FALSE))) %>%
  unnest(country_pairs) %>%
  mutate(from = map_chr(country_pairs, 1), 
         to = map_chr(country_pairs, 2)) %>%
  select(from, to) %>%
  count(from, to, sort = TRUE) %>%
  rename(weight = n)  # Rename 'n' to 'weight' for edge thickness

# Create graph object
country_graph <- graph_from_data_frame(edges, directed = FALSE)

# Calculate node size based on total collaborations
node_sizes <- data.frame(name = V(country_graph)$name) %>%
  left_join(edges %>% 
              group_by(from) %>% 
              summarise(size = sum(weight)), 
            by = c("name" = "from")) %>%
  replace_na(list(size = 1))  # Replace missing values with 1

# Enhanced network graph visualization
ggraph(country_graph, layout = "fr") +  
  geom_edge_link(aes(edge_width = weight, alpha = weight), color = "gray") +  
    scale_edge_width(range = c(0.5, 5), trans = "log10") +  # Proper log-scaling
  geom_node_point(aes(size = node_sizes$size), color = "darkblue") +  
  geom_node_text(aes(label = name), repel = TRUE, size = 5, fontface = "bold") +  
  theme_void() +  
  labs(title = "Enhanced Movie Co-Production Network",
       subtitle = "Edge thickness represents number of collaborations",
       edge_width = "Co-Productions")

```






