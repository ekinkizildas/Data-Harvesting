library(scrapex)
library(dotenv)
library(httr)
library(jsonlite)
library(furrr)
library(httr)
library(jsonlite)
library(tidyverse)
library(furrr)
library(httr)
library(jsonlite)
library(tidyverse)
library(furrr)
library(httr)
library(jsonlite)
library(tidyverse)
library(furrr)
dotenv::load_dot_env()
knitr::opts_chunk$set(echo = TRUE)
library(dotenv)
load_dot_env("api_key_au.env")
api_key <- Sys.getenv("API_KEY")
knitr::opts_chunk$set(echo = TRUE)
usethis::edit_r_environ()
knitr::opts_chunk$set(echo = TRUE)
library(dotenv)
# ✅ Enable parallel processing (4 workers)
plan(multisession, workers = 4)
usethis::edit_r_environ()
api_key <- Sys.getenv("api_key")
usethis::edit_r_environ()
library(scrapex)
library(dotenv)
library(httr)
library(jsonlite)
library(furrr)
library(httr)
library(jsonlite)
library(tidyverse)
library(furrr)
library(httr)
library(jsonlite)
library(tidyverse)
library(furrr)
library(httr)
library(jsonlite)
library(tidyverse)
library(furrr)
usethis::edit_r_environ()
api_key <- Sys.getenv("api_key")
api_key <- Sys.getenv("api_key")
# ✅ Enable parallel processing (4 workers)
plan(multisession, workers = 4)
# ✅ Define time range
start_year <- 2000
end_year <- as.numeric(format(Sys.Date(), "%Y"))
# ✅ Define countries
countries <- c("US", "GB", "DE", "FR", "TR", "IN", "JP", "ES", "IT", "BR")
# ✅ Define selected languages
languages <- c("es", "fr", "de", "tr", "ja", "ru", "zh", "ko", "pt", "hi", "it")
### **STEP 1: Fetch Top 50 Movies Per Language (Faster)**
fetch_movies_by_language <- function(lang) {
movies_list <- list()
for (page in 1:2) {  # ✅ Limit to first 2 pages (~50 movies per language)
movie_url <- paste0("https://api.themoviedb.org/3/discover/movie?api_key=", api_key,
"&sort_by=popularity.desc",
"&primary_release_date.gte=", start_year, "-01-01",
"&primary_release_date.lte=", end_year, "-12-31",
"&vote_count.gte=500",
"&with_original_language=", lang,
"&page=", page)
response <- tryCatch({
GET(movie_url, timeout(10))
}, error = function(e) NULL)
Sys.sleep(runif(1, 1, 2))  # ✅ Shorter delay (1-2 sec)
if (!is.null(response) && status_code(response) == 200) {
movies <- fromJSON(content(response, "text", encoding = "UTF-8"))$results
if (!is.null(movies) && length(movies) > 0) {
movie_df <- tibble(
movie_id = movies$id,
title = movies$title,
language = lang,
popularity = movies$popularity,
genre_ids = sapply(movies$genre_ids, function(x) paste(x, collapse = ",")) # ✅ Store genre codes
)
movies_list <- append(movies_list, list(movie_df))
}
}
}
if (length(movies_list) > 0) {
return(bind_rows(movies_list))
} else {
return(NULL)
}
}
# ✅ Fetch movies in parallel
all_movies <- future_map_dfr(languages, fetch_movies_by_language, .progress = TRUE)
library(future)
# ✅ Enable parallel processing (4 workers)
plan(multisession, workers = 4)
# ✅ Define time range
start_year <- 2000
end_year <- as.numeric(format(Sys.Date(), "%Y"))
# ✅ Define countries
countries <- c("US", "GB", "DE", "FR", "TR", "IN", "JP", "ES", "IT", "BR")
# ✅ Define selected languages
languages <- c("es", "fr", "de", "tr", "ja", "ru", "zh", "ko", "pt", "hi", "it")
### **STEP 1: Fetch Top 50 Movies Per Language (Faster)**
fetch_movies_by_language <- function(lang) {
movies_list <- list()
for (page in 1:2) {  # ✅ Limit to first 2 pages (~50 movies per language)
movie_url <- paste0("https://api.themoviedb.org/3/discover/movie?api_key=", api_key,
"&sort_by=popularity.desc",
"&primary_release_date.gte=", start_year, "-01-01",
"&primary_release_date.lte=", end_year, "-12-31",
"&vote_count.gte=500",
"&with_original_language=", lang,
"&page=", page)
response <- tryCatch({
GET(movie_url, timeout(10))
}, error = function(e) NULL)
Sys.sleep(runif(1, 1, 2))  # ✅ Shorter delay (1-2 sec)
if (!is.null(response) && status_code(response) == 200) {
movies <- fromJSON(content(response, "text", encoding = "UTF-8"))$results
if (!is.null(movies) && length(movies) > 0) {
movie_df <- tibble(
movie_id = movies$id,
title = movies$title,
language = lang,
popularity = movies$popularity,
genre_ids = sapply(movies$genre_ids, function(x) paste(x, collapse = ",")) # ✅ Store genre codes
)
movies_list <- append(movies_list, list(movie_df))
}
}
}
if (length(movies_list) > 0) {
return(bind_rows(movies_list))
} else {
return(NULL)
}
}
# ✅ Fetch movies in parallel
all_movies <- future_map_dfr(languages, fetch_movies_by_language, .progress = TRUE)
